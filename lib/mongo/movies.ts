import clientPromise from '.';
import { MongoClient, Db, Collection, ObjectId } from 'mongodb';

// Define the Movie interface
interface Movie {
  _id?: string | ObjectId; // Optional because it will be generated by MongoDB
  title: string;
  year: number;
  genre: string;
  director: string;
  rating: number;
}

let client: MongoClient | undefined;
let db: Db | undefined;
let movies: Collection<Movie> | undefined;

// Initialize the MongoDB client and database
async function init(): Promise<void> {
  if (db) return;
  try {
    client = await clientPromise;
    db = client.db('movie'); // database name
    movies = db.collection('transport'); // collection name
  } catch (error) {
    throw new Error('Failed to establish connection to database');
  }
}

// Fetch multiple movies
export async function getMovies(): Promise<{
  movies?: Movie[];
  error?: string;
}> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const result = await movies.find({}).toArray();

    return {
      movies: result.map((movie) => ({ ...movie, _id: movie._id.toString() })),
    };
  } catch (error) {
    return { error: 'Failed to fetch movies' };
  }
}

// Fetch a single movie by ID
export async function getMovieById(
  id: string
): Promise<{ movie?: Movie; error?: string }> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const movie = await movies.findOne({ _id: new ObjectId(id) });

    if (!movie) {
      return { error: 'Movie not found' };
    }

    return { movie: { ...movie, _id: movie._id.toString() } };
  } catch (error) {
    return { error: 'Failed to fetch movie' };
  }
}

export async function getMoviesByQuery(
  query: Record<string, any> = {}
): Promise<{
  movies?: Movie[];
  error?: string;
}> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const queryObject: Record<string, any> = {};

    for (const [key, value] of Object.entries(query)) {
      if (value) {
        queryObject[key] = value;
      }
    }

    const result = await movies.find(queryObject).toArray();

    return {
      movies: result.map((movie) => ({ ...movie, _id: movie._id.toString() })),
    };
  } catch (error) {
    return { error: 'Failed to fetch movies' };
  }
}

// Add a new movie
export async function addMovie(
  movie: Movie
): Promise<{ movie?: Movie; error?: string }> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const result = await movies.insertOne(movie);
    const newMovie = await movies.findOne({ _id: result.insertedId });

    if (!newMovie) {
      return { error: 'Failed to create movie' };
    }

    return { movie: { ...newMovie, _id: newMovie._id.toString() } };
  } catch (error) {
    return { error: 'Failed to add movie' };
  }
}

// Delete a movie by ID
export async function deleteMovie(
  id: string
): Promise<{ success: boolean; error?: string }> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const objectId = new ObjectId(id);
    const result = await movies.deleteOne({ _id: objectId });

    if (result.deletedCount === 0) {
      return { success: false, error: 'Movie not found' };
    }

    return { success: true };
  } catch (error) {
    return { success: false, error: 'Failed to delete movie' };
  }
}

export async function updateMovie(
  id: string,
  updates: Partial<Movie>
): Promise<{ movie?: Movie; error?: string }> {
  try {
    if (!movies) await init();

    if (!movies) {
      throw new Error('Collection "movies" is not initialized');
    }

    const objectId = new ObjectId(id);
    const movie = await movies.findOneAndUpdate(
      { _id: objectId },
      { $set: updates },
      { returnDocument: 'after' }
    );

    if (!movie) {
      return { error: 'Movie not found' };
    }

    return { movie: { ...movie, _id: movie._id.toString() } };
  } catch (error) {
    return { error: 'Failed to update movie' };
  }
}
